Java官方API将线程的整个生命周期分为如下 6 个状态：

1. `New`：线程被创建后的状态，还未开始执行。
2. `Runnable`：调用线程的 `start()` 方法后，线程变成 `Runnable` 状态，表示线程可以被执行，等待系统进行线程调度并分配 CPU 时间片进行执行。
3. `Waiting`：线程执行了某些操作（如 `wait()`、`join()` 等）时，会进入 `Waiting` 状态，等待其他线程的某些操作，之后再恢复自身的执行。
4. `Timed Waiting`：类似于 `Waiting` 状态，线程执行了某些有时间限制的操作（如 `sleep()`、`wait(long)` 等）时，
    会进入 `Timed Waiting` 状态。当指定的时间过去后，线程会自动恢复到 `Runnable` 状态。
5. `Blocked`：线程等待获取一个内部锁（如 synchronized 块或方法）时，若该锁已被其他线程占有，则进入 `Blocked` 状态。
    等待获取锁的线程直到锁释放才会被唤醒，然后进入 `Runnable` 状态。
6. `Terminated`：线程执行完成或出现了异常退出时，进入 `Terminated` 状态。一旦进入此状态，该线程的生命周期结束，无法再次进入 `Runnable` 状态。

可以粗略地理解为：Blocked 状态是被动阻塞，等待其他线程唤醒；而 Timed Waiting 状态是主动等待，等待一定的时间或特定的条件满足后被自动唤醒。
Waiting 状态是一种无限等待的状态，只有其他线程调用对应的 notify() 或 notifyAll() 方法才会被唤醒；
在 Blocked 状态下，线程处于一种等待状态，其被堵塞的根本原因是获取了同步锁或同步资源，但是由于该锁被其他线程持有，而无法获取。
线程进入 Blocked 状态后，只有当其他线程释放锁资源时，该线程才会被唤醒，重新进入 Runnable 状态。
而在 Timed Waiting 状态下，线程处于一种等待状态，但是其等待的时限是可控的，
即可以自己设置一个等待时长，一旦等待时长结束就会自动进入 Runnable 状态。



wait()方法和sleep()方法都可以让线程处于暂停状态，暂停的时间可以通过方法的参数进行指定。但是它们之间有以下几个不同点：
1. wait()方法和sleep()方法的对象不同：wait()方法只能在同步块或同步方法中使用，它会释放它所持有的锁，并且支持唤醒操作；
   而sleep()方法可以在任何地方使用，它并不会释放锁。
2. wait()方法和sleep()方法的作用不同：wait()方法会将线程挂起并且释放它所持有的锁，进入对象的等待队列中，
   只有当其他线程调用notify()或notifyAll()方法并释放锁之后，等待线程才有可能重新获得锁并继续运行；
   而sleep()方法只是让线程暂停执行一段时间，之后会重新进入就绪状态并抢占CPU资源。
3. wait()方法和sleep()方法会抛出不同的异常：wait()方法会抛出InterruptedException异常和IllegalMonitorStateException异常；
   而sleep()方法只会抛出InterruptedException异常。
4. wait()方法和sleep()方法对cpu时间片的影响不同：wait()方法在释放锁之后就进入Waiting状态，不再继续参与CPU的资源竞争。
   而sleep()方法则只是让线程暂停执行一段时间，之后依然可以参与CPU的资源竞争，只是在一段时间内不会获得CPU的执行权。
   综上所述，wait()方法和sleep()方法虽然有些相似之处，但一些重要的细节和用法上还是有很大的区别的。需要根据具体的业务场景和需要进行选择和使用。