<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>固定定位</title>
    <style>
      body {
        width: 60%;
        margin: 0 auto; /*距离上侧、下侧0px 左右自动*/
      }
      .fixed {
        position: fixed;  /*固定不动*/
        top: 0;
        margin: 0;
        width: 600px;
        height: 60px;
        border: 1px solid red;
        background-color: #ffc400;
      }
    </style>
</head>
<body>
    <h1 class="fixed">固定定位</h1>
    <p>虚拟线程是一种轻量化的线程封装，由jvm直接调度和管理。反之普通的线程其实是调用的操作系统的能力，对应的是操作系统级的线程。</p>
    <p>相对虚拟线程来说操作系统级的线程持有成本很高，而且受操作系统调度和管理的。实际在普通多线程情况下，如果出现IO阻塞，</p>
    <p>这个线程就必须得跟着阻塞，这个线程对应的操作系统就被阻塞，而他却持有大量的内存。</p>
    <p>另外，要处理大量的IO就得新建更多线程，而大量的线程会在操作系统切换时因上下文切换导致大量的CPU被浪费。</p>
    <p>虚拟线程是一种轻量化的线程封装，由jvm直接调度和管理。反之普通的线程其实是调用的操作系统的能力，对应的是操作系统级的线程。</p>
    <p>相对虚拟线程来说操作系统级的线程持有成本很高，而且受操作系统调度和管理的。实际在普通多线程情况下，如果出现IO阻塞，</p>
    <p>这个线程就必须得跟着阻塞，这个线程对应的操作系统就被阻塞，而他却持有大量的内存。</p>
    <p>另外，要处理大量的IO就得新建更多线程，而大量的线程会在操作系统切换时因上下文切换导致大量的CPU被浪费。</p>
    <p>虚拟线程是一种轻量化的线程封装，由jvm直接调度和管理。反之普通的线程其实是调用的操作系统的能力，对应的是操作系统级的线程。</p>
    <p>相对虚拟线程来说操作系统级的线程持有成本很高，而且受操作系统调度和管理的。实际在普通多线程情况下，如果出现IO阻塞，</p>
    <p>这个线程就必须得跟着阻塞，这个线程对应的操作系统就被阻塞，而他却持有大量的内存。</p>
    <p>另外，要处理大量的IO就得新建更多线程，而大量的线程会在操作系统切换时因上下文切换导致大量的CPU被浪费。</p>
    <p>虚拟线程是一种轻量化的线程封装，由jvm直接调度和管理。反之普通的线程其实是调用的操作系统的能力，对应的是操作系统级的线程。</p>
    <p>相对虚拟线程来说操作系统级的线程持有成本很高，而且受操作系统调度和管理的。实际在普通多线程情况下，如果出现IO阻塞，</p>
    <p>这个线程就必须得跟着阻塞，这个线程对应的操作系统就被阻塞，而他却持有大量的内存。</p>
    <p>另外，要处理大量的IO就得新建更多线程，而大量的线程会在操作系统切换时因上下文切换导致大量的CPU被浪费。</p>
    <p>虚拟线程是一种轻量化的线程封装，由jvm直接调度和管理。反之普通的线程其实是调用的操作系统的能力，对应的是操作系统级的线程。</p>
    <p>相对虚拟线程来说操作系统级的线程持有成本很高，而且受操作系统调度和管理的。实际在普通多线程情况下，如果出现IO阻塞，</p>
    <p>这个线程就必须得跟着阻塞，这个线程对应的操作系统就被阻塞，而他却持有大量的内存。</p>
    <p>另外，要处理大量的IO就得新建更多线程，而大量的线程会在操作系统切换时因上下文切换导致大量的CPU被浪费。</p>
    <p>虚拟线程是一种轻量化的线程封装，由jvm直接调度和管理。反之普通的线程其实是调用的操作系统的能力，对应的是操作系统级的线程。</p>
    <p>相对虚拟线程来说操作系统级的线程持有成本很高，而且受操作系统调度和管理的。实际在普通多线程情况下，如果出现IO阻塞，</p>
    <p>这个线程就必须得跟着阻塞，这个线程对应的操作系统就被阻塞，而他却持有大量的内存。</p>
    <p>另外，要处理大量的IO就得新建更多线程，而大量的线程会在操作系统切换时因上下文切换导致大量的CPU被浪费。</p>
</body>
</html>